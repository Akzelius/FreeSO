/*The contents of this file are subject to the Mozilla Public License Version 1.1
(the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at http://www.mozilla.org/MPL/

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is the GonzoNet.

The Initial Developer of the Original Code is
Mats 'Afr0' Vederhus. All Rights Reserved.

Contributor(s): ______________________________________.
*/

using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using System.IO;
using System.Diagnostics;

namespace GonzoNet.Encryption
{
	/// <summary>
	/// Encryptor for the AES encryption algorithm.
	/// </summary>
	public class AESEncryptor : Encryptor
	{
		private byte[] m_Challenge = new byte[16];
		private byte[] m_PublicKey;
		private ECDiffieHellmanCng m_PrivateKey = new ECDiffieHellmanCng();

		RNGCryptoServiceProvider m_Random = new RNGCryptoServiceProvider();
		private byte[] m_NOnce = new byte[16];

		/// <summary>
		/// Gets or sets the challenge for this session.
		/// Issued by server and received by client.
		/// </summary>
		public byte[] Challenge
		{
			get { return m_Challenge; }
			set { lock (m_Challenge) { m_Challenge = value; } }
		}

		/// <summary>
		/// Gets or sets the private key.
		/// Should be the opposite of the public key, I.E if the public key is the client's,
		/// the private should be the server's and vice versa.
		/// </summary>
		public ECDiffieHellmanCng PrivateKey
		{
			get { return m_PrivateKey; }
			set { lock (m_PrivateKey) { m_PrivateKey = value; } }
		}

		/// <summary>
		/// Gets or sets the public key.
		/// Should be the opposite of the private key, I.E if the private key is the client's,
		/// the public should be the server's and vice versa.
		/// </summary>
		public byte[] PublicKey
		{
			get { return m_PublicKey; }
			set { m_PublicKey = value; }
		}

		/// <summary>
		/// Gets or sets the NOnce, used for encryption.
		/// Generated by client or server, and sent to the other party.
		/// </summary>
		public byte[] NOnce
		{
			get { return m_NOnce; }
			set { lock (m_NOnce) { m_NOnce = value; } }
		}

		/// <summary>
		/// Creates a new AESEncryptor instance, which can be used to
		/// encrypt and decrypt data with AES.
		/// </summary>
		/// <param name="Password">User's password.</param>
		public AESEncryptor(string Password)
			: base(Password)
		{
			m_PrivateKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
			m_PrivateKey.HashAlgorithm = CngAlgorithm.Sha256;
			m_Random.GetNonZeroBytes(m_NOnce);
			m_Random.GetNonZeroBytes(m_Challenge);
		}

		/// <summary>
		/// Creates a new DecryptionArgsContainer instance containing this AESEncryptor's NOnce and PrivateKey.
		/// </summary>
		/// <returns>A new DecryptionArgsContainer.</returns>
		public override DecryptionArgsContainer GetDecryptionArgsContainer()
		{
			DecryptionArgsContainer Container = new DecryptionArgsContainer();
			Container.AESDecryptArgs = new AESDecryptionArgs();
			Container.AESDecryptArgs.NOnce = m_NOnce;
			Container.AESDecryptArgs.PrivateKey = m_PrivateKey;
			Container.AESDecryptArgs.Challenge = m_Challenge;

			return Container;
		}

		/// <summary>
		/// Constructs an encrypted packet.
		/// </summary>
		/// <param name="PacketID">The ID of the packet.</param>
		/// <param name="PacketData">The data to encrypt.</param>
		/// <returns>A byte array containing the ID, length of the encrypted data and the encrypted data.</returns>
		public override byte[] FinalizePacket(byte PacketID, byte[] PacketData)
		{
			MemoryStream PacketStream = new MemoryStream();
			BinaryWriter PacketWriter = new BinaryWriter(PacketStream);

			PacketWriter.Write(PacketID);

			byte[] EncryptedData = StaticStaticDiffieHellman.Encrypt(m_PrivateKey,
				ECDiffieHellmanCngPublicKey.FromByteArray(m_PublicKey, CngKeyBlobFormat.EccPublicBlob),
				m_NOnce, PacketData);

			//The length of the encrypted data can be longer or smaller than the original length,
			//so write the length of the encrypted data.
			PacketWriter.Write((uint)(PacketHeaders.ENCRYPTED + EncryptedData.Length));
			//Also write the length of the unencrypted data.
			PacketWriter.Write(PacketData.Length);
			PacketWriter.Flush();

			PacketWriter.Write(EncryptedData);
			PacketWriter.Flush();

			return PacketStream.ToArray();
		}

		/// <summary>
		/// Decrypts the contents of the provided PacketStream instance.
		/// </summary>
		/// <param name="EncryptedPacket">An encrypted PacketStream instance.</param>
		/// <param name="DecryptionArgs">A DecryptionArgsContainer instance.</param>
		/// <returns>A MemoryStream instance with the decrypted data.</returns>
		public override MemoryStream DecryptPacket(PacketStream EncryptedPacket, DecryptionArgsContainer DecryptionArgs)
		{
			try
			{
				byte[] EncryptedData = new byte[EncryptedPacket.Length - (int)PacketHeaders.ENCRYPTED];
				EncryptedPacket.Read(EncryptedData, 0, EncryptedData.Length);

				byte[] DecryptedData = StaticStaticDiffieHellman.Decrypt(m_PrivateKey,
					ECDiffieHellmanCngPublicKey.FromByteArray(m_PublicKey, CngKeyBlobFormat.EccPublicBlob),
					m_NOnce, EncryptedData);

				return new MemoryStream(DecryptedData);
			}
			catch (Exception e)
			{
				Debug.WriteLine("Exception in DecryptPacket: " + e.ToString());
				return null;
			}
		}
	}
}